# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @rdname ddiff
#' @export
pdiff <- function(rt, ch, alpha, theta, xi, tau, eta = as.numeric( c(0.0)), stheta = as.numeric( c(0.0)), stau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), eps = 1e-29, parYes = 1L) {
    .Call('seqmodels_pdiff', PACKAGE = 'seqmodels', rt, ch, alpha, theta, xi, tau, eta, stheta, stau, sigma, eps, parYes)
}

#' @rdname ddiff
#' @export
rdiff <- function(N, alpha, theta, xi, tau, eta = as.numeric( c(0.0)), stheta = as.numeric( c(0.0)), stau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), eps = 1e-29, mxRT = 4.0, em_stop = 20, err = .0001, parYes = 1L) {
    .Call('seqmodels_rdiff', PACKAGE = 'seqmodels', N, alpha, theta, xi, tau, eta, stheta, stau, sigma, eps, mxRT, em_stop, err, parYes)
}

#' The Exponentially Modified Gaussian Distribution
#'
#' Random generation, density, distribution, and quantile functions for
#' the distribution of the convolution of gaussian and exponential
#' random varibles.
#'
#' @param N the number of draws for random generation.
#' @param x a vector of quantiles.
#' @param mu a vector of the means for the gaussian variable.
#' @param sigma a vector of standard deviations for the gaussian variable
#'   (sigma > 0).
#' @param lambda a vector of rates for the exponential variable
#'   (lambda > 0).
#' @param ln indicates whether the log-likelihood should be returned,
#'   where 1 = True, 0 = False (the default).
#'
#' @section Details:
#' An exponentially modified gaussian distribution describes the sum of
#' independent normal and exponential random variables, possessing
#' a characteristic positive skew due to the exponential variable.
#'
#' For unequal vector lengths, values are recycled.
#'
#' @section References:
#' Forthcoming
#'
#' @examples
#' Forthcoming
#'
#' @export
remg <- function(N, mu, sigma, lambda) {
    .Call('seqmodels_remg', PACKAGE = 'seqmodels', N, mu, sigma, lambda)
}

#' @rdname remg
#' @export
demg <- function(x, mu, sigma, lambda, ln = 0L) {
    .Call('seqmodels_demg', PACKAGE = 'seqmodels', x, mu, sigma, lambda, ln)
}

#' @rdname remg
#' @export
pemg <- function(x, mu, sigma, lambda) {
    .Call('seqmodels_pemg', PACKAGE = 'seqmodels', x, mu, sigma, lambda)
}

#' @rdname remg
#' @export
qemg <- function(p, mu, sigma, lambda, mnRT = -1.0, mxRT = 4.0, em_stop = 20L, err = 0.001) {
    .Call('seqmodels_qemg', PACKAGE = 'seqmodels', p, mu, sigma, lambda, mnRT, mxRT, em_stop, err)
}

#' @useDynLib seqmodels
#' @importFrom Rcpp sourceCpp
NULL

#' The Ratcliff diffusion model
#'
#' Density, distribution, and random generation functions
#' for the diffusion model (e.g. Ratcliff & Tuerlinckx, 2002).
#'
#' @param rt a vector of responses times ( rt > 0 ).
#' @param ch a vector of accuracy/choice values ( ch = {0,1} ).
#' @param alpha a vector of upper boundaries at which the evidence
#'   accumulation terminations.
#' @param theta a vector of proportions determining the starting
#'   point for the evidence accumulation, where the starting point
#'   zeta = alpha*theta ( 0 >= theta >= 1 ).
#' @param xi a vector of drift rates, the rate of evidence accumulation
#'   ( xi > 0 ).
#' @param tau a vector of residual latencies for the non-decision
#'   component ( tau > 0 ).
#' @param eta a vector of standard deviations for the trial-to-trial
#'   variability in the drift rate (eta > 0). A value results in no
#'   trial-to-trial variability.
#' @param stheta a vector of the ranges for the uniform variability
#'   about the starting point ( 0 <= theta +/- (stheta/2) <= 1). A
#'   value results in no trial-to-trial variability.
#' @param stau a vector of the ranges for the uniform variability
#'   about the residual latency ( 0 <= tau - (stau/2) ). A
#'   value results in no trial-to-trial variability.
#' @param sigma a vector of within-trial variabilities, the drift
#'   coefficient ( sigma > 0 ).
#' @param eps the margin of error for the infinite sums being calculated
#'   ( default is 1e-29 ).
#' @param ln indicates whether the likelihood (ln = 0 ) or the
#'   log-likelihood ( ln = 1 ) should be calculated ( default is 0 ).
#' @param mxRT the maximum RT response time value that the algorithm is applied to.
#' @param em_step the maximum number of iterations for the linear interpolation.
#' @param err the desired degree of precision for the linear interpolation.
#'
#' @section Details:
#' The density function is based on the implementation of Navarro
#' and Fuss (2009). The distribution function is based on the
#' implementation of Blurton et al. (2012). For parameter variability
#' the functions use numerical integration with adaptive quadrature.
#' For unequal vector lengths, values are recycled.
#'
#' @section References:
#' Blurton, S. P., Kesselmeier, M., & Gondan, M. (2012). Fast and
#'   accurate calculations for cumulative first-passage time distributions
#'   in Wiener diffusion models. Journal of Mathematical Psychology,
#'   56, 470-475.
#' Navarro, D. J., & Fuss, I. G. (2009). Fast and accurate calculations
#'   for first-passage times in Wiener diffusion models. Journal of
#'   Mathematical Psychology, 53, 222-230.
#' Ratcliff, R., & Tuerlinckx, F. (2002). Estimating parameters of the
#'   diffusion model: Approaches to dealing with contaminant reaction
#'   times and parameter variability. Psychonomic Bulletin & Review, 9,
#'   438-481.
#'
#' @export
ddiff <- function(rt, ch, alpha, theta, xi, tau, eta = as.numeric( c(0.0)), stheta = as.numeric( c(0.0)), stau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), eps = 1e-29, ln = 0L, parYes = 1L) {
    .Call('seqmodels_ddiff', PACKAGE = 'seqmodels', rt, ch, alpha, theta, xi, tau, eta, stheta, stau, sigma, eps, ln, parYes)
}

#' The Inverse Gaussian Distribution
#'
#' Random generation, density, distribution, and quantile functions
#' for the inverse gaussian (or Wald) distribution.
#'
#' @param N the number of draws for random generation.
#' @param t a vector of quantiles (typically response times).
#' @param kappa a vector of thresholds determining when a decision
#'   terminates (kappa > 0).
#' @param xi a vector of drift rates, or rates of evidence accumulation
#'   (xi > 0).
#' @param sigma a vector of the within-trial variabilities
#'   (sigma > 0).
#' @param ln indicates whether the log-likelihood should be returned,
#'   where 1 = True, 0 = False (the default).
#' @param mxT the maximum time that the quantile function algorithm is
#'   applied to.
#' @param em_step the maximum number of iterations for the linear
#'   interpolation used in the quantile function.
#' @param err the desired degree of precision for the linear interpolation
#'   used in the quantile function.
#'
#' @section Details:
#' The inverse gaussian distribution describes the first passage times
#' through a positive threshold kappa for a space and time homogenous
#' Wiener diffusion process. The current functions use a parameterization
#' suitable for sequential sampling models.
#'
#' For unequal vector lengths, values are recycled.
#'
#' @section References:
#' Johnson, N. L., Kotz, S., & Balakrishnan, N. (1994). Inverse Gaussian
#'   (Wald) distributions. In N. L. Johnson, S. Kotz, & N. Balakrishnan
#'   (Eds.), Continuous univariate distributions (2nd ed., Vol. 1, pp.
#'   259-297). New York: Wiley.
#' Michael, J. R., Schucany, W. R., & Haas, R. W. (1976). Generating
#'   random variates using transformations with multiple roots.
#'   The American Statistician, 30 (2), 88-90. doi:10.2307/2683801.
#'
#' @examples
#' # Treatment of illegal values and vectorization
#' set.seed(100)
#' rinvgauss(8,c(1,2,-1,1),c(1,.5,1,-1),c(1,1,1,1)) # Returns NA
#' dinvgauss( c(.5, -1), c(1,2,-1,1),c(1,.4,1,-1),c(1,1,1,1) ) # Returns 0
#' pinvgauss( c(.5, -1), c(1,2,-1,1),c(1,.4,1,-1),c(1,1,1,1) ) # Returns 0
#'
#' # Demonstrates how parameters kappa and xi scale with different values of sigma
#' t = seq(0,1,length=1000)
#' plot( t, dinvgauss(t,.1,.2,.1), type = 'l', bty ='l', xlab = 'Time', ylab = 'Density', lwd = 2 )
#' lines( t, dinvgauss(t,1,2,1), col = 'red', lty = 2, lwd = 2 )
#'
#' # Distribution function
#' plot( t, pinvgauss(t,1,2,1), type = 'l', xlab = 'Time', ylab = 'Distribution', bty = 'l', yaxt = 'n' )
#' axis(2,seq(.2,.8,.2))
#' # Quantile function
#' prb = seq( .2, .8, .2 ) # Probabilities
#' qnt = qinvgauss( prb, 1, 2, 1 )
#' segments( rep(0,length(prb)), prb, qnt, prb )
#' segments( qnt,rep(0,length(prb)), qnt, prb )
#'
#' @export
rinvgauss <- function(N, kappa, xi, sigma) {
    .Call('seqmodels_rinvgauss', PACKAGE = 'seqmodels', N, kappa, xi, sigma)
}

#' @rdname rinvgauss
#' @export
dinvgauss <- function(t, kappa, xi, sigma, ln = 0L) {
    .Call('seqmodels_dinvgauss', PACKAGE = 'seqmodels', t, kappa, xi, sigma, ln)
}

#' @rdname rinvgauss
#' @export
pinvgauss <- function(t, kappa, xi, sigma) {
    .Call('seqmodels_pinvgauss', PACKAGE = 'seqmodels', t, kappa, xi, sigma)
}

#' @rdname rinvgauss
#' @export
qinvgauss <- function(p, kappa, xi, sigma, mxT = 4.0, em_stop = 20L, err = .0001) {
    .Call('seqmodels_qinvgauss', PACKAGE = 'seqmodels', p, kappa, xi, sigma, mxT, em_stop, err)
}

#' The Wald Race Model
#'
#' Random generation, density, distribution, and quantile functions for
#' a two accumulator version of the Wald (or diffusion) race model
#' (Logan et al., 2014).
#'
#' @param N the number of observations to simulate.
#' @param rt a vector of response times (rt > 0).
#' @param ch a vector of choices (ch = {0,1}).
#' @param k1 the threshold determining when a decision terminates for
#'   choices == 1 ( k1 > 0).
#' @param xi1 the average rate of evidence accumulation within a trial
#'   for choices == 1 (xi1 > 0).
#' @param tau1 the residual latency for choices == 1 (tau1 >= 0).
#' @param k0 the threshold determining when a decision terminates for
#'   choices == 0 ( k0 > 0).
#' @param xi0 the average rate of evidence accumulation within a trial
#'   for choices == 0 (xi0 > 0).
#' @param tau0 the residual latency for choices == 0 (tau0 >= 0).
#' @param s0 the within trial variability for choices == 0 (s0 > 0).
#' @param s1 the within trial variability for choices == 1 (s1 > 0).
#' @param rl if 1, the residual latency impacts the decision rule.
#' @param ln indicates whether the log-likelihood should be returned,
#'   where 1 = True, 0 = False (the default).
#' @param mxRT the maximum RT response time value that the algorithm is applied to.
#' @param em_step the maximum number of iterations for the linear interpolation.
#' @param err the desired degree of precision for the linear interpolation.
#' @param joint If 1, indicates that the probabilities are based on the joint
#'   distribution function.
#' @param parYes if set to 1, the code is run in parallel.
#'
#' @section Details:
#' The Wald (or diffusion) race model assumes that two independent one
#' boundary diffusion processes race each other. Whichever racer reaches
#' its threshold first determines the choice and response time. Because
#' of the independence, the likelihood for the Wald race model is:
#' \deqn{ f(t,y|\alpha)*(1-F(t,y|\beta)},
#' where \eqn{\alpha} and \eqn{\beta} are the sets of parameters for
#' the Wald distribution describing the finishing times for the
#' winning and losing racer respectively, and \eqn{f} and \eqn{F} refer
#' to the density and distribution functions respectively.
#'
#' @section Notes:
#' For unequal vector lengths, values are recycled. For random draws,
#' inadmissible values return NA.
#'
#' @section References:
#' Logan, G. D., Van Zandt, T., Verbruggen, F., & Wagenmakers, E. J.
#'   (2014). On the ability to inhibit thought and action: General
#'   and special theories of an act of control. Psychological Review,
#'   121, 66.
#'
#' @examples
#' # Treatment of illegal values and vectorization
#' set.seed(200)
#' rwaldrace( 8, c(1,2,-1,1), c(4,1,1,1), c(.2,-.1), 1, 1, .2 ) # Returns NA
#' dwaldrace( .5, 1, c(1,-2,1), 4, .2, c(1,1,-2), 1, .2 )
#'
#' # Density function
#' rt = seq(0,1,length=1000)
#' plot( rt, dwaldrace( rt, 1, .1, .4, .2, .1, .2, .2, s1 = .1, s0 = .1 ),
#'   type = 'l', bty ='l', xlab = 'Time', ylab = 'Density' )
#' lines( rt, dwaldrace( rt, 0, 1, 4, .2, 1, 2, .2 ), lty = 2 )
#'
#' # Distribution function
#' rt = seq(0,2,length=1000)
#' pwaldrace( Inf, 1, 1.8, 3, .2, 1.4, 1, .2 ) # Choice probabilities
#' plot( rt, pwaldrace( rt, 1, 1.8, 3, .2, 1.4, 1, .2 ), type = 'l',
#'   xlab = 'Time', ylab = 'Distribution', bty = 'l', yaxt = 'n' )
#' axis(2,seq(.2,.8,.2))
#' # Quantile function
#' prb = seq( .1, .7, .2 ) # Probabilities
#' qnt = qwaldrace( prb, 1, 1.8, 3, .2, 1.4, 1, .2 )
#' segments( rep(0,length(prb)), prb, qnt, prb )
#' segments( qnt,rep(0,length(prb)), qnt, prb )
#'
#' @export
rwaldrace <- function(N, k1, xi1, tau1, k0, xi0, tau0, s1 = as.numeric( c(1.0)), s0 = as.numeric( c(1.0)), rl = 0L) {
    .Call('seqmodels_rwaldrace', PACKAGE = 'seqmodels', N, k1, xi1, tau1, k0, xi0, tau0, s1, s0, rl)
}

#' @rdname rwaldrace
#' @export
dwaldrace <- function(rt, ch, k1, xi1, tau1, k0, xi0, tau0, s1 = as.numeric( c(1.0)), s0 = as.numeric( c(1.0)), rl = 0.0, ln = 0L) {
    .Call('seqmodels_dwaldrace', PACKAGE = 'seqmodels', rt, ch, k1, xi1, tau1, k0, xi0, tau0, s1, s0, rl, ln)
}

#' @rdname rwaldrace
#' @export
pwaldrace <- function(rt, ch, k1, xi1, tau1, k0, xi0, tau0, s1 = as.numeric( c(1.0)), s0 = as.numeric( c(1.0)), rl = 0.0, parYes = 1L) {
    .Call('seqmodels_pwaldrace', PACKAGE = 'seqmodels', rt, ch, k1, xi1, tau1, k0, xi0, tau0, s1, s0, rl, parYes)
}

#' @rdname rwaldrace
#' @export
qwaldrace <- function(p, ch, k1, xi1, tau1, k0, xi0, tau0, s1 = as.numeric( c(1.0)), s0 = as.numeric( c(1.0)), rl = 0.0, mxRT = 4.0, em_stop = 20.0, err = 0.001, joint = 1.0, parYes = 1L) {
    .Call('seqmodels_qwaldrace', PACKAGE = 'seqmodels', p, ch, k1, xi1, tau1, k0, xi0, tau0, s1, s0, rl, mxRT, em_stop, err, joint, parYes)
}

