# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The Exponentially Modified Gaussian Distribution
#'
#' Random generation, density, distribution, quantile, and
#' descriptive moments functions for the the convolution of gaussian
#' and exponential random variables (the ex-gaussian distribution),
#' with location equal to \code{mu}, scale equal to \code{sigma} and
#' rate equal to \code{lambda}.
#'
#' @param x,q vector of quantiles.
#' @param p vector of probabilities.
#' @param n number of observations to be generated.
#' @param mu vector of location parameters for the gaussian
#'   variable.
#' @param sigma vector of scale parameters (i.e., standard
#'   deviations) for the gaussian variable (sigma > 0).
#' @param lambda vector of rate parameters for the exponential
#'   variable (lambda > 0).
#' @param ln logical; if \code{TRUE}, probabilities are given as
#'   log(p).
#' @param lower_tail logical; if \code{TRUE} (default), probabilities
#'   are \eqn{P(X \le x)} otherwise \eqn{P( X > x)}.
#' @param bounds lower and upper limits of the quantiles to explore
#'   for the approximation via linear interpolation.
#' @param em_stop the maximum number of iterations to attempt to
#'   find the quantile via linear interpolation.
#' @param err the number of decimals places to approximate the
#'   cumulative probability during estimation of the quantile function.
#'
#' @section Details:
#' An exponentially modified gaussian distribution describes the sum of
#' independent normal and exponential random variables, possessing
#' a characteristic positive skew due to the exponential variable.
#' The ex-gaussian distribution is therefore useful for providing
#' descriptive fits to response time distributions (e.g., Luce, 1986).
#'
#' A linear interpolation approach is used to approximate the
#' quantile function, estimating the inverse of the cumulative
#' distribution function via an iterative procedure. When
#' the precision of this estimate is set to 8 decimal places,
#' the approximation will be typically accurate to about half of a
#' millisecond.
#'
#' The example section demonstrates how to compute maximum likelihood
#' estimates based on the moments from a set of data.
#'
#' @return
#' \code{demg} gives the density, \code{pemg} gives the
#' distribution function, \code{qemg} gives the quantile function,
#' \code{memg} computes the descriptive moments (mean, variance,
#' standard deviation, skew, and excess kurtosis), and \code{remg}
#' generates random deviates.
#'
#' The length of the result is determined by \code{n} for
#' \code{remg}, and is the maximum of the lengths of the numerical
#' arguments for the other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the
#' length of the result.
#'
#' @section References:
#'
#' Luce, R. D. (1986). Response times: Their role in inferring
#'   elementary mental organization. New York, New York: Oxford
#'   University Press.
#'
#' Terriberry, T. B. (2007). Computing Higher-Order Moments Online.
#'   Retrieved from https://people.xiph.org/~tterribe/notes/homs.html
#'
#' @examples
#' # Density function
#' demg( x = 0.8758, mu = 0.0, sigma = 1.0, lambda = 1.0 )
#' # Distribution function
#' pemg( q = 0.8758, mu = 0.0, sigma = 1.0, lambda = 1.0 )
#' # Quantile function (Accurate to ~4 decimal places)
#' round( qemg( p = .5, mu = 0.0, sigma = 1.0, lambda = 1.0 ), 4 )
#' # Descriptive moments
#' memg( mu = 0.44, sigma = 0.07, lambda = 2.0 )
#'
#' # Simulation
#' sim <- remg( n = 1000, mu = 0.44, sigma = 0.07, lambda = 2.0 );
#'
#' # Function to obtain maximum likelihood estimates
#' param_est <- function( dat ) {
#'   # Compute 1st, 2nd, and 3rd moments ( Terriberry, 2007).
#'   n <- 0; m <- 0; m2 <- 0; m3 <- 0;
#'   for ( k in 1:length( dat ) ) {
#'     n1 <- n; n <- n + 1
#'     term1 <- dat[k] - m; term2 = term1/ n; term3 = term1 * term2 * n1
#'     # Update first moment
#'     m <- m + term2
#'     # Update third moment
#'     m3 <- m3 + term3 + term2 * (n - 2) - 3 * term2 * m2
#'     # Update second moment
#'     m2 <- m2 + term3
#'   }
#'   # Compute standard deviation of sample
#'   s <- sqrt( m2 / ( n - 1.0 ) )
#'   # Compute skewness of sample
#'   y <- sqrt( n ) * m3 / ( m2^1.5 );
#'   # Estimate parameters
#'   mu_hat <- m - s * ( y/2 )^(1/3)
#'   sigma_hat <- sqrt( (s^2) * ( 1 - (y/2)^(2/3) ) )
#'   lambda_hat <- 1/( s * (y/2)^(1/3) )
#'   return( c( mu = mu_hat, sigma = sigma_hat, lambda = lambda_hat ) )
#' }
#'
#' print( param_est( sim ) )
#'
#' # Plotting
#' layout( matrix( 1:4, 2, 2, byrow = T ) )
#' # Parameters
#' prm <- c( m = .44, s = .07, l = 2.0 )
#' # Density
#' obj <- quickdist( 'emg', 'PDF', prm )
#' plot( obj ); lines( obj )
#' # CDF
#' obj <- quickdist( 'emg', 'CDF', prm )
#' plot( obj ); lines( obj )
#' # Quantiles
#' obj <- quickdist( 'emg', 'QF', prm, x = seq( .2, .8, .2 ) )
#' plot( obj ); prb = seq( .2, .8, .2 );
#' abline( h = prb, lty = 2 );
#' lines( obj, type = 'b', pch = 19 )
#' # Hazard function
#' obj <- quickdist( 'emg', 'HF', prm )
#' plot( obj ); lines( obj )
#'
#' @export
remg <- function(n, mu, sigma, lambda) {
    .Call('_seqmodels_remg', PACKAGE = 'seqmodels', n, mu, sigma, lambda)
}

#' @rdname remg
#' @export
demg <- function(x, mu, sigma, lambda, ln = FALSE) {
    .Call('_seqmodels_demg', PACKAGE = 'seqmodels', x, mu, sigma, lambda, ln)
}

#' @rdname remg
#' @export
pemg <- function(q, mu, sigma, lambda, ln = FALSE, lower_tail = TRUE) {
    .Call('_seqmodels_pemg', PACKAGE = 'seqmodels', q, mu, sigma, lambda, ln, lower_tail)
}

#' @rdname remg
#' @export
qemg <- function(p, mu, sigma, lambda, bounds = as.numeric( c( 0.0, 3.0)), em_stop = 20, err = 1e-8) {
    .Call('_seqmodels_qemg', PACKAGE = 'seqmodels', p, mu, sigma, lambda, bounds, em_stop, err)
}

#' @rdname remg
#' @export
memg <- function(mu, sigma, lambda) {
    .Call('_seqmodels_memg', PACKAGE = 'seqmodels', mu, sigma, lambda)
}

#' The Levy Distribution
#'
#' Density, distribution, random generation, and quantile functions
#' for the Levy distribution, where \code{mu} is a location parameter
#' and \code{sigma} is a scale parameter.
#'
#' @param n the number of draws for random generation.
#' @param x,q a vector of quantiles (must be greater than mu).
#' @param mu a vector of location parameters.
#' @param sigma a vector of scale parameters (sigma > 0).
#' @param ln logical; if \code{TRUE}, probabilities are given as
#'   log(p).
#' @param lower_tail logical; if \code{TRUE} (default), probabilities
#'   are \eqn{P(X \le x)} otherwise \eqn{P( X > x)}.
#'
#' @section Details:
#' A Levy distribution, among other things, can describe the finishing
#' times for a one boundary wiener process when the drift rate is
#' fixed to zero.
#'
#' The mean and variance for the Levy distribution are non-finite.
#'
#' @return
#' \code{dlevy} gives the density, \code{plevy} gives the
#' distribution function, \code{qlevy} gives the quantile function
#' and \code{rlevy} generates random deviates.
#'
#' The length of the result is determined by \code{n} for
#' \code{rlevy}, and is the maximum of the lengths of the numerical
#' arguments for the other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the
#' length of the result.
#'
#' @section References:
#'
#' Applebaum, D. (2010). Lectures on Levy processes and stochastic
#'   calculus, Braunschweig; Lecture 2: Levy processes. Retrieved from
#'   http://www.applebaum.staff.shef.ac.uk/Brauns2notes.pdf.
#'
#' Siegrist, K. (1997). The Levy distribution. Retrieved from
#'   http://www.math.uah.edu/stat/special/Levy.html
#'
#' @examples
#' # Density
#' dlevy( x = 2.199, mu = 0.0, sigma = 1.0 )
#' # Distribution function
#' plevy( q = 2.199, mu = 0.0, sigma = 1.0 )
#' # Quantile function
#' qlevy( p = .5, mu = 0.0, sigma = 1.0 )
#'
#' # Simulations
#' sim <- rlevy( n = 1000, mu = 0.0, sigma = 1.0 )
#'
#' @export
dlevy <- function(x, mu, sigma, ln = FALSE) {
    .Call('_seqmodels_dlevy', PACKAGE = 'seqmodels', x, mu, sigma, ln)
}

#' @rdname dlevy
#' @export
plevy <- function(q, mu, sigma, lower_tail = TRUE, ln = FALSE) {
    .Call('_seqmodels_plevy', PACKAGE = 'seqmodels', q, mu, sigma, lower_tail, ln)
}

#' @rdname dlevy
#' @export
qlevy <- function(p, mu, sigma) {
    .Call('_seqmodels_qlevy', PACKAGE = 'seqmodels', p, mu, sigma)
}

#' @rdname dlevy
#' @export
rlevy <- function(n, mu, sigma) {
    .Call('_seqmodels_rlevy', PACKAGE = 'seqmodels', n, mu, sigma)
}

#' The Shifted Inverse Gaussian Distribution
#'
#' Random generation, density, distribution, and quantile functions
#' for the shifted inverse gaussian (or Wald) distribution,
#' parameterized for Brownian motion. \code{kappa} refers to the
#' threshold, \code{xi} refers to the rate of evidence accumulation
#' towards this threshold, \code{tau} is the shift in response times
#' and \code{sigma} refers to the within-trial variability for the
#' rate of evidence accumulation (the coefficient of drift, typically
#' fixed to 1).
#'
#' @param n the number of draws for random generation.
#' @param t a vector of times ( t > 0 ).
#' @param kappa a vector of thresholds determining when a decision
#'   terminates (kappa > 0).
#' @param xi a vector of drift rates, or rates of evidence accumulation
#'   (xi \eqn{\ge} 0).
#' @param tau a vector of shift parameters denoting the lowest
#'   possible time that can be observed (0 \eqn{\ge} tau < t).
#' @param sigma a vector of the within-trial variabilities
#'   (sigma > 0).
#' @param ln logical; if \code{TRUE}, probabilities are given as
#'   log(p).
#' @param lower_tail logical; if \code{TRUE} (default), probabilities
#'   are \eqn{P(X \le x)} otherwise \eqn{P( X > x)}.
#' @param bounds upper limit of the quantiles to explore  for the
#'   approximation via linear interpolation.
#' @param em_stop the maximum number of iterations to attempt to
#'   find the quantile via linear interpolation.
#' @param err the number of decimals places to approximate the
#'   cumulative probability during estimation of the quantile function.
#'
#' @section Details:
#' The inverse gaussian distribution describes the first passage times
#' through a positive threshold kappa for a space and time homogenous
#' Wiener diffusion process.
#'
#' A linear interpolation approach is used to approximate the
#' quantile function, estimating the inverse of the cumulative
#' distribution function via an iterative procedure. When
#' the precision of this estimate is set to 8 decimal places,
#' the approximation will be typically accurate to about half of a
#' millisecond.
#'
#' The example section demonstrates how to compute maximum likelihood
#' estimates based on the moments from a set of data.
#'
#' @return
#' \code{dinvgauss} gives the density, \code{pinvgauss} gives the
#' distribution function, \code{qinvgauss} approximates the quantile
#' function, \code{minvgauss} computes the descriptive moments (mean,
#' variance, standard deviation, skew, and excess kurtosis), and
#' \code{rinvgauss} generates random deviates.
#'
#' The length of the result is determined by \code{n} for
#' \code{rinvgauss}, and is the maximum of the length of the
#' numerical arguments for the other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the
#' length of the result.
#'
#' @section References:
#'
#' Dagpunar, J. (1988). Principles of Random Variate Generation.
#'   Oxford: Clarendon Press.
#'
#' Heathcote, A. (2004a). Fitting Wald and ex-Wald distributions to
#'   response time data: An example using functions for the S-PLUS
#'   package. Behavior Research Methods Instruments & Computers, 36,
#'   678 - 694.
#'
#' Heathcote, A. (2004b). rtfit.ssc. Retrieved May 5, 2017 from
#'   Psychonomic Society Web Archive:
#'   http://www.psychonomic.org/ARCHIVE/.
#'
#' @examples
#' # Density
#' dinvgauss( .9758, kappa = 1.0, xi = 1.0, tau = 0.3 )
#' # Distribution function
#' pinvgauss( .9758, kappa = 1.0, xi = 1.0, tau = 0.3 )
#' # Quantile function (Accurate to ~4 decimal places)
#' round( qinvgauss( p = .5, kappa = 1.0, xi = 1.0, tau = 0.3 ), 4 )
#' # Descriptive moments
#' minvgauss( kappa = 1.0, xi = 1.0, tau = 0.3 )
#'
#' # Simulation (No shift)
#' sim <- rinvgauss( 1000, kappa = 0.8, xi = 2.0 )
#'
#' # Function to obtain maximum likelihood estimates
#' param_est <- function( dat, tau_hat = 0 ) {
#'   # Estimate threshold and drift from first two moments of
#'   # data (Heathcote, 2004):
#'   dat <- dat - tau_hat # Apply shift
#'   xi_hat <- sqrt( mean( dat )/var( dat ) );
#'   kappa_hat <- xi_hat * mean( dat );
#'   return( c( kappa = kappa_hat, xi = xi_hat, tau = tau_hat ) )
#' }
#' print( param_est( sim ) )
#'
#' # Non-zero shift parameter
#' sim <- rinvgauss( 1000, kappa = 1.6, xi = 1.5, tau = .3 )
#'
#' # Estimating shift parameter
#'
#' # Function to compute sum of log-likelihoods
#' f <- function( tau_hat, dat ) {
#'   prm = param_est( dat, tau_hat = tau_hat )
#'   sll = sum( dinvgauss( dat, prm[1], prm[2], tau = prm[3], ln = T ) )
#'   return( sll )
#' }
#' tau_hat <- optimize( f, c( 0.0, min( sim ) ), dat = sim, maximum = T )
#' print( param_est( sim, tau_hat = tau_hat$maximum ) )
#'
#' # Plotting
#' layout( matrix( 1:4, 2, 2, byrow = T ) )
#' # Parameters
#' prm <- c( k = 0.8, x = 1.6, t = 0.3, s = 1.0 )
#' # Density
#' obj <- quickdist( 'sig', 'PDF', prm )
#' plot( obj ); lines( obj )
#' # CDF
#' obj <- quickdist( 'sig', 'CDF', prm )
#' plot( obj ); lines( obj )
#' # Quantiles
#' obj <- quickdist( 'sig', 'QF', prm, x = seq( .2, .8, .2 ) )
#' plot( obj ); prb = seq( .2, .8, .2 )
#' abline( h = prb, lty = 2 ); lines( obj, type = 'b', pch = 19 )
#' # Hazard function
#' obj <- quickdist( 'sig', 'HF', prm )
#' plot( obj ); lines( obj )
#'
#' @export
rinvgauss <- function(n, kappa, xi, tau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0))) {
    .Call('_seqmodels_rinvgauss', PACKAGE = 'seqmodels', n, kappa, xi, tau, sigma)
}

#' @rdname rinvgauss
#' @export
dinvgauss <- function(t, kappa, xi, tau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), ln = FALSE) {
    .Call('_seqmodels_dinvgauss', PACKAGE = 'seqmodels', t, kappa, xi, tau, sigma, ln)
}

#' @rdname rinvgauss
#' @export
pinvgauss <- function(t, kappa, xi, tau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), ln = FALSE, lower_tail = TRUE) {
    .Call('_seqmodels_pinvgauss', PACKAGE = 'seqmodels', t, kappa, xi, tau, sigma, ln, lower_tail)
}

#' @rdname rinvgauss
#' @export
qinvgauss <- function(p, kappa, xi, tau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0)), bounds = 3.0, em_stop = 20, err = 1e-8) {
    .Call('_seqmodels_qinvgauss', PACKAGE = 'seqmodels', p, kappa, xi, tau, sigma, bounds, em_stop, err)
}

#' @rdname rinvgauss
#' @export
minvgauss <- function(kappa, xi, tau = as.numeric( c(0.0)), sigma = as.numeric( c(1.0))) {
    .Call('_seqmodels_minvgauss', PACKAGE = 'seqmodels', kappa, xi, tau, sigma)
}

#' @useDynLib seqmodels
#' @importFrom Rcpp sourceCpp
NULL

#' Two-boundary Wiener Process for Choice and Response Times
#'
#' Density, distribution, quantile, and random generation functions
#' for a two-boundary wiener process that can be applied to
#' choice and response times (e.g., Luce, 1986; Ratcliff, 1978).
#' \code{alpha} refers to the boundary separation, \code{theta}
#' refers to the proportion governing the start point of accumulation,
#' \code{xi} refers to the rate of evidence accumulation (drift rate),
#' \code{tau} refers to the residual latency (e.g., motor and
#' encoding processes), and \code{sigma} refers to the within-trial
#' variability of evidence accumulation (the coefficient of drift;
#' typically set to 1 or 0.1).
#'
#' @param n the number of draws for random generation.
#' @param rt a vector of responses times ( \code{rt} > 0 ).
#' @param p a vector of probabilities.
#' @param ch a vector of accuracy/choice values ( \code{ch} = {0,1} ).
#' @param alpha a vector of upper boundaries at which the evidence
#'   accumulation terminations.
#' @param theta a vector of proportions determining the starting
#'   point for the evidence accumulation, where the starting point
#'   \eqn{\zeta} = \code{alpha}*\code{theta} ( 0 \eqn{\ge} \code{theta}
#'   \eqn{\ge} 1 ).
#' @param xi a vector of drift rates, the rate of evidence accumulation
#'   ( \code{xi} > 0 ).
#' @param tau a vector of residual latencies for the non-decision
#'   component ( \code{tau} > 0 ).
#' @param sigma a vector giving the coefficients of drift (also known as
#'   within-trial variability; \code{sigma} > 0 ).
#' @param eps the margin of error for the infinite sums being calculated.
#' @param ln logical; if \code{TRUE}, probabilities are given as
#'   log(p).
#' @param joint logical; if \code{FALSE} the conditional density
#'   (normalized to integrate to one) is returned. Otherwise, the
#'   joint density (integrating to the choice probability) is
#'   returned.
#' @param lower_tail logical; if \code{TRUE} (default), probabilities
#'   are \eqn{P(X \le x)} otherwise \eqn{P( X > x)}.
#' @param bounds upper limit of the quantiles to explore
#'   for the approximation via linear interpolation.
#' @param em_stop the maximum number of iterations to attempt to
#'   find the quantile via linear interpolation.
#' @param err the number of decimals places to approximate the
#'   cumulative probability during estimation of the quantile function.
#' @param parYes logical; if \code{TRUE} the code is run in parallel.
#'
#' @section Details:
#' The density function is based on the implementation of Navarro
#' and Fuss (2009). The distribution function is based on the
#' implementation of Blurton et al. (2012).
#'
#' A linear interpolation approach is used to approximate the
#' quantile function and to random deviates by estimating the
#' inverse of the cumulative distribution function via an
#' iterative procedure. When the precision of this estimate is
#' set to 8 decimal places, the approximation will be typically
#' accurate to about half of a millisecond.
#'
#' @return
#' \code{dwiener} gives the density, \code{pwiener} gives the
#' distribution function, \code{qwiener} approximates the quantile
#' function, and \code{rwiener} generates random deviates.
#'
#' The length of the result is determined by \code{n} for \code{rwiener},
#' and is the maximum of the length of the numerical arguments for
#' the other functions.
#'
#' The numerical arguments other than \code{n} are recycled to the
#' length of the result.
#'
#' @section References:
#'
#' Blurton, S. P., Kesselmeier, M., & Gondan, M. (2012). Fast and
#'   accurate calculations for cumulative first-passage time distributions
#'   in Wiener diffusion models. Journal of Mathematical Psychology,
#'   56, 470-475.
#'
#' Luce, R. D. (1986). Response times: Their role in inferring
#'   elementary mental organization. New York, New York: Oxford University
#'   Press.
#'
#' Navarro, D. J., & Fuss, I. G. (2009). Fast and accurate calculations
#'   for first-passage times in Wiener diffusion models. Journal of
#'   Mathematical Psychology, 53, 222-230.
#'
#' Ratcliff, R. (1978). A theory of memory retrieval. Psychological
#'   review, 85, 59 - 108.
#'
#' @examples
#' # Density
#' dwiener( rt = 0.6, ch = c( 1, 0 ), alpha = 1.6, theta = 0.5,
#'   xi = 1.0, tau = 0.3 )
#' # Distribution function
#' pwiener( rt = 0.6, ch = c( 1, 0 ), alpha = 1.6, theta = 0.5,
#'   xi = 1.0, tau = 0.3 )
#' # Choice probabilities
#' pwiener( rt = Inf, ch = c( 1, 0 ), alpha = 1.6, theta = 0.5,
#'   xi = 1.0, tau = 0.3 )
#' # Quantile function (Accurate to ~4 decimal places)
#' round( qwiener( p = .3499, ch = 1, alpha = 1.6, theta = 0.5,
#'   xi = 1.0, tau = 0.3 ), 4 )
#' # For quantiles based on joint distribution, re-weight input 'p'
#' # based on choice probabilities
#' prob <- pwiener( rt = Inf, ch = c( 1, 0 ), alpha = 1.6, theta = 0.5,
#'   xi = 1.0, tau = 0.3 )
#' round( qwiener( p = .3499 * prob, ch = c( 1, 0), alpha = 1.6,
#'   theta = 0.5, xi = 1.0, tau = 0.3 ), 4 )
#' # Simulate values
#' sim <- rwiener( n = 100, alpha = 0.8, theta = 0.6,
#'   xi = 0.0, tau = 0.3 )
#'
#' # Plotting
#' layout( matrix( 1:4, 2, 2, byrow = T ) )
#' # Parameters
#' prm <- c( a = 1.2, z = .4, v = 1.0, t0 = 0.3 )
#' # Density
#' obj <- quickdist( 'wp', 'PDF', prm )
#' plot( obj ); lines( obj ); lines( obj, ch = 0, lty = 2 )
#' # CDF
#' obj <- quickdist( 'wp', 'CDF', prm )
#' plot( obj ); lines( obj ); lines( obj, ch = 0, lty = 2 )
#' # Quantiles
#' obj <- quickdist( 'wp', 'QF', prm, x = seq( .2, .8, .2 ) )
#' plot( obj ); prb = seq( .2, .8, .2 )
#' abline( h = prb, lty = 2 )
#' # Conditional, not joint
#' lines( obj, type = 'b', pch = 19, weight = 1 )
#' lines( obj, ch = 0, type = 'b', pch = 17, lty = 2, weight = 1 )
#' # Hazard function
#' obj <- quickdist( 'wp', 'HF', prm )
#' plot( obj ); lines( obj ); lines( obj, ch = 0, lty = 2 )
#'
#' @export
dwiener <- function(rt, ch, alpha, theta, xi, tau, sigma = as.numeric( c(1.0)), ln = FALSE, joint = TRUE, eps = 1e-29, parYes = TRUE) {
    .Call('_seqmodels_dwiener', PACKAGE = 'seqmodels', rt, ch, alpha, theta, xi, tau, sigma, ln, joint, eps, parYes)
}

#' @rdname dwiener
#' @export
pwiener <- function(rt, ch, alpha, theta, xi, tau, sigma = as.numeric( c(1.0)), ln = FALSE, joint = TRUE, lower_tail = TRUE, eps = 1e-29, parYes = TRUE) {
    .Call('_seqmodels_pwiener', PACKAGE = 'seqmodels', rt, ch, alpha, theta, xi, tau, sigma, ln, joint, lower_tail, eps, parYes)
}

#' @rdname dwiener
#' @export
qwiener <- function(p, ch, alpha, theta, xi, tau, sigma = as.numeric( c(1.0)), joint = FALSE, eps = 1e-29, bounds = 3.0, em_stop = 20, err = 1e-8, parYes = TRUE) {
    .Call('_seqmodels_qwiener', PACKAGE = 'seqmodels', p, ch, alpha, theta, xi, tau, sigma, joint, eps, bounds, em_stop, err, parYes)
}

#' @rdname dwiener
#' @export
rwiener <- function(n, alpha, theta, xi, tau, sigma = as.numeric( c(1.0)), eps = 1e-29, bounds = 5.0, em_stop = 30, err = 1e-16, parYes = TRUE) {
    .Call('_seqmodels_rwiener', PACKAGE = 'seqmodels', n, alpha, theta, xi, tau, sigma, eps, bounds, em_stop, err, parYes)
}

